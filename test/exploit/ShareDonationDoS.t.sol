// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title ShareDonationDoS
 * @notice Tests verifying Share Donation DoS Attack is FIXED
 * @dev VULNERABILITY (FIXED): An attacker could donate shares to block withdrawals
 *
 * ROOT CAUSE: The escrow invariant check used strict equality (!=)
 * FIX: Changed to >= check (balance < pendingWithdrawalShares)
 *
 * Now donated shares are tolerated - they can be recovered via recoverOrphanedShares()
 * but they don't block withdrawal operations.
 */
contract ShareDonationDoS is Test {
    USDCSavingsVault public vault;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    uint256 public constant FEE_RATE = 0.2e18;
    uint256 public constant COOLDOWN = 1 days;

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);

        vault = new USDCSavingsVault(
            address(usdc),
            address(roleManager),
            multisig,
            treasury,
            FEE_RATE,
            COOLDOWN,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        roleManager.setOperator(operator, true);
        vault.setMaxYieldChangePercent(0);
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 10_000_000e6);
        usdc.mint(victim, 10_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice Verify: Share donation does NOT block fulfillWithdrawals (FIXED)
     */
    function test_FIXED_ShareDonation_DoesNotBlockFulfillWithdrawals() public {
        console2.log("=== SHARE DONATION DoS - VERIFIED FIXED ===");
        console2.log("");

        // Setup: Victim deposits and requests withdrawal
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        console2.log("Victim deposited 1M USDC, received shares:", victimShares);

        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);
        console2.log("Victim requested withdrawal, requestId:", requestId);

        // Attacker gets some shares and donates
        vm.prank(attacker);
        vault.deposit(100e6);

        vm.prank(attacker);
        vault.transfer(address(vault), 1); // Donate 1 wei
        console2.log("Attacker donated 1 wei of shares to vault");

        // Check state
        uint256 vaultBalance = vault.balanceOf(address(vault));
        uint256 pendingShares = vault.pendingWithdrawalShares();
        console2.log("Vault share balance:", vaultBalance);
        console2.log("Pending withdrawal shares:", pendingShares);
        console2.log("Excess (donated):", vaultBalance - pendingShares);

        // Wait for cooldown
        vm.warp(block.timestamp + COOLDOWN + 1);

        // Fulfill withdrawal - NOW WORKS despite donation
        vm.prank(operator);
        (uint256 processed, uint256 paid) = vault.fulfillWithdrawals(1);

        console2.log("");
        console2.log("Withdrawal processed:", processed);
        console2.log("USDC paid:", paid);
        assertEq(processed, 1, "Should process 1 withdrawal");
        assertGt(paid, 0, "Should pay USDC");

        console2.log("");
        console2.log("=== VULNERABILITY FIXED ===");
        console2.log("Share donations no longer block withdrawals");
    }

    /**
     * @notice Verify: Share donation does NOT block cancelWithdrawal (FIXED)
     */
    function test_FIXED_ShareDonation_DoesNotBlockCancelWithdrawal() public {
        console2.log("=== CANCEL WITHDRAWAL - VERIFIED FIXED ===");
        console2.log("");

        // Setup
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);

        // Attacker donates
        vm.prank(attacker);
        vault.deposit(100e6);
        vm.prank(attacker);
        vault.transfer(address(vault), 1);
        console2.log("Attacker donated 1 wei of shares");

        // Victim cancels - NOW WORKS
        vm.prank(victim);
        vault.cancelWithdrawal(requestId);

        uint256 victimBalance = vault.balanceOf(victim);
        console2.log("Victim shares after cancel:", victimBalance);
        assertEq(victimBalance, victimShares, "Victim should get shares back");

        console2.log("");
        console2.log("Cancel withdrawal works despite donation - FIXED");
    }

    /**
     * @notice Verify: Share donation does NOT block forceProcessWithdrawal (FIXED)
     */
    function test_FIXED_ShareDonation_DoesNotBlockForceProcess() public {
        console2.log("=== FORCE PROCESS - VERIFIED FIXED ===");
        console2.log("");

        // Setup
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);

        // Attacker donates
        vm.prank(attacker);
        vault.deposit(100e6);
        vm.prank(attacker);
        vault.transfer(address(vault), 1);
        console2.log("Attacker donated 1 wei of shares");

        // Force process - NOW WORKS
        vault.forceProcessWithdrawal(requestId);

        uint256 victimUsdc = usdc.balanceOf(victim);
        console2.log("Victim USDC after force:", victimUsdc);
        assertGt(victimUsdc, 0, "Victim should receive USDC");

        console2.log("");
        console2.log("Force process works despite donation - FIXED");
    }

    /**
     * @notice Verify: Orphaned shares can still be recovered
     */
    function test_FIXED_OrphanedSharesCanBeRecovered() public {
        console2.log("=== ORPHANED SHARE RECOVERY ===");
        console2.log("");

        // Setup with pending withdrawal
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        vm.prank(victim);
        vault.requestWithdrawal(victimShares / 2);

        // Attacker donates
        vm.prank(attacker);
        vault.deposit(100e6);
        vm.prank(attacker);
        vault.transfer(address(vault), 100e18); // Donate 100 shares
        console2.log("Attacker donated 100 shares");

        uint256 balanceBefore = vault.balanceOf(address(vault));
        uint256 pending = vault.pendingWithdrawalShares();
        console2.log("Vault balance:", balanceBefore);
        console2.log("Pending shares:", pending);
        console2.log("Orphaned:", balanceBefore - pending);

        // Recover orphaned shares
        uint256 recovered = vault.recoverOrphanedShares();
        console2.log("Recovered:", recovered);
        assertEq(recovered, 100e18, "Should recover donated shares");

        uint256 balanceAfter = vault.balanceOf(address(vault));
        assertEq(balanceAfter, pending, "Balance should now equal pending");

        console2.log("");
        console2.log("Orphaned shares recovered successfully");
    }

    /**
     * @notice Verify: Multiple donations don't accumulate problems
     */
    function test_FIXED_MultipleDonationsHandled() public {
        console2.log("=== MULTIPLE DONATIONS HANDLED ===");
        console2.log("");

        vm.prank(victim);
        vault.deposit(1_000_000e6);

        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1_000_000e6);

        // Multiple donations
        for (uint256 i = 0; i < 5; i++) {
            vm.prank(attacker);
            vault.transfer(address(vault), 1);
        }
        console2.log("Attacker made 5 small donations");

        // Request and fulfill withdrawal
        vm.prank(victim);
        vault.requestWithdrawal(100_000e18);
        vm.warp(block.timestamp + COOLDOWN + 1);

        vm.prank(operator);
        (uint256 processed,) = vault.fulfillWithdrawals(1);
        assertEq(processed, 1, "Should process withdrawal");
        console2.log("Withdrawal processed successfully");

        // Recover orphaned
        uint256 recovered = vault.recoverOrphanedShares();
        console2.log("Recovered orphaned shares:", recovered);
        assertEq(recovered, 5, "Should recover 5 wei of shares");

        console2.log("");
        console2.log("Multiple donations handled correctly - FIXED");
    }
}
