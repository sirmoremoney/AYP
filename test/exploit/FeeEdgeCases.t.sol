// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {VaultShare} from "../../src/VaultShare.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title FeeEdgeCases
 * @notice Tests for simplified yield-based fee calculation edge cases
 * @dev Analyzes:
 *      1. Fee calculation at extreme yields
 *      2. Fee on zero/negative yield
 *      3. Division by zero scenarios
 *      4. Fee atomicity with yield reporting
 */
contract FeeEdgeCases is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);

        vault = new USDCSavingsVault(
            address(usdc),
            address(roleManager),
            multisig,
            treasury,
            0.2e18, // 20% fee
            1 days,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        vault.setMaxYieldChangePercent(0);
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 100_000_000e6);
        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice Test: Fee at extreme yield (>100%)
     * @dev FINDING: HANDLED - Fee minting works correctly at extreme yields
     */
    function test_ANALYSIS_FeeAtExtremeYield() public {
        console2.log("=== FEE AT EXTREME YIELD ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before:", priceBefore);

        // Extreme yield: 500% - fees collected atomically
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(5_000_000e6);

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after 500% yield:", priceAfter);

        uint256 treasuryShares = shares.balanceOf(treasury);
        console2.log("Treasury received shares:", treasuryShares);
        assertTrue(treasuryShares > 0, "Treasury should receive fees");

        console2.log("");
        console2.log("RESULT: Fee collection handled correctly at extreme yield");
    }

    /**
     * @notice Test: No fee on zero yield
     * @dev FINDING: CORRECT - Zero yield produces zero fees
     */
    function test_ANALYSIS_FeeOnZeroYield() public {
        console2.log("=== FEE ON ZERO YIELD ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(100_000e6);

        uint256 treasuryBefore = shares.balanceOf(treasury);

        // Report zero yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(0);

        uint256 treasuryAfter = shares.balanceOf(treasury);
        console2.log("Treasury before:", treasuryBefore);
        console2.log("Treasury after:", treasuryAfter);
        assertEq(treasuryAfter, treasuryBefore, "No fees on zero yield");

        console2.log("");
        console2.log("RESULT: Correctly handles zero yield (no fees)");
    }

    /**
     * @notice Test: No fee on negative yield (loss)
     * @dev FINDING: CORRECT - Negative yield produces zero fees
     */
    function test_ANALYSIS_NoFeeOnNegativeYield() public {
        console2.log("=== NO FEE ON NEGATIVE YIELD ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        // First report positive yield to establish treasury balance
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);

        uint256 treasuryBefore = shares.balanceOf(treasury);
        console2.log("Treasury after gain:", treasuryBefore);

        // Report negative yield (loss)
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(-50_000e6);

        uint256 treasuryAfter = shares.balanceOf(treasury);
        console2.log("Treasury after loss:", treasuryAfter);
        assertEq(treasuryAfter, treasuryBefore, "No fees on loss");

        console2.log("");
        console2.log("RESULT: Correctly handles negative yield (no fees)");
    }

    /**
     * @notice Test: Consecutive positive yields each trigger fees
     * @dev FINDING: EXPECTED - Each positive yield report triggers fee collection
     */
    function test_ANALYSIS_ConsecutivePositiveYields() public {
        console2.log("=== CONSECUTIVE POSITIVE YIELDS ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        // First yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);
        uint256 treasury1 = shares.balanceOf(treasury);
        console2.log("Treasury after 1st yield:", treasury1);

        // Second yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);
        uint256 treasury2 = shares.balanceOf(treasury);
        console2.log("Treasury after 2nd yield:", treasury2);

        // Third yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);
        uint256 treasury3 = shares.balanceOf(treasury);
        console2.log("Treasury after 3rd yield:", treasury3);

        assertTrue(treasury3 > treasury2, "Each yield should add fees");
        assertTrue(treasury2 > treasury1, "Each yield should add fees");

        console2.log("");
        console2.log("RESULT: Each positive yield report triggers proportional fee");
    }

    /**
     * @notice Test: Fee atomicity - cannot separate yield report from fee collection
     * @dev FINDING: SECURE - Fees are collected atomically with yield
     */
    function test_ANALYSIS_FeeAtomicity() public {
        console2.log("=== FEE ATOMICITY ===");
        console2.log("");

        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1_000_000e6);

        // With simplified model, there's no way to report yield without collecting fees
        // reportYieldAndCollectFees is the ONLY way to report yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);

        uint256 treasuryShares = shares.balanceOf(treasury);
        assertTrue(treasuryShares > 0, "Fees collected atomically with yield");

        // Yield reporting and fee collection are bundled in a single function
        // ensuring fees cannot be bypassed

        console2.log("Treasury shares:", treasuryShares);
        console2.log("");
        console2.log("RESULT: Fee collection is atomic with yield reporting");
    }

    /**
     * @notice Test: Fee calculation with very small deposit
     * @dev FINDING: Edge case where fee rounds to 0 shares
     */
    function test_ANALYSIS_SmallDepositFeeRounding() public {
        console2.log("=== SMALL DEPOSIT FEE ROUNDING ===");
        console2.log("");

        // Very small deposit
        vm.prank(attacker);
        vault.deposit(1e6); // 1 USDC

        // Small yield (1%)
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(0.01e6);

        uint256 treasuryShares = shares.balanceOf(treasury);
        console2.log("Treasury shares from small yield:", treasuryShares);

        // Fee = 0.01e6 * 0.2 = 0.002e6 USDC worth of shares
        // This is a very small amount but should still mint some shares
        console2.log("");
        console2.log("RESULT: Small fees handled (may round to 0 shares)");
    }
}
