// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {VaultShare} from "../../src/VaultShare.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title FlashLoanArbitrage
 * @notice Tests for flash loan and front-running attack vectors
 * @dev Tests whether the protocol is vulnerable to:
 *      1. Flash loan deposit/withdraw arbitrage
 *      2. Sandwich attacks on yield reports
 *      3. Front-running deposits before yield
 */
contract FlashLoanArbitrage is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    uint256 public constant FEE_RATE = 0.2e18;
    uint256 public constant COOLDOWN = 1 days;

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);

        vault = new USDCSavingsVault(
            address(usdc),
            address(roleManager),
            multisig,
            treasury,
            FEE_RATE,
            COOLDOWN,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        vault.setMaxYieldChangePercent(0); // Disable for testing
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 100_000_000e6);
        usdc.mint(victim, 100_000_000e6);
        usdc.mint(multisig, 100_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(multisig);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice Test: Flash loan to front-run yield report
     * @dev FINDING: NOT PROFITABLE - Cooldown period prevents immediate withdrawal
     *      Even if attacker deposits before yield, they must wait COOLDOWN (1 day)
     *      to withdraw, giving time for price to normalize or more users to enter.
     */
    function test_ANALYSIS_FlashLoanYieldFrontrun_Blocked() public {
        console2.log("=== FLASH LOAN YIELD FRONT-RUN ANALYSIS ===");
        console2.log("");

        // Initial state: Victim has deposited
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before yield:", priceBefore);

        // Attacker sees yield report in mempool, tries to front-run
        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(10_000_000e6); // Large deposit
        console2.log("Attacker deposited 10M USDC, got shares:", attackerShares);

        // Yield is reported
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6); // 10% yield on 1M

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after yield:", priceAfter);

        // Attacker wants to withdraw immediately - BUT CANNOT
        // They must request withdrawal and wait COOLDOWN
        vm.prank(attacker);
        vault.requestWithdrawal(attackerShares);
        console2.log("Attacker requested withdrawal");

        // Try to fulfill immediately - FAILS due to cooldown
        vm.prank(operator);
        (uint256 processed,) = vault.fulfillWithdrawals(1);
        assertEq(processed, 0, "Should not process - cooldown not met");
        console2.log("Fulfillment blocked - cooldown not met");

        console2.log("");
        console2.log("RESULT: Flash loan attack NOT PROFITABLE");
        console2.log("Cooldown period (1 day) prevents immediate exit");
    }

    /**
     * @notice Test: Sandwich attack on yield report
     * @dev FINDING: Partially mitigated by fee collection timing
     *      Fees are collected BEFORE share calculation in deposit(),
     *      so sandwicher buys at post-fee price.
     */
    function test_ANALYSIS_SandwichYieldReport() public {
        console2.log("=== SANDWICH ATTACK ON YIELD REPORT ===");
        console2.log("");

        // Initial depositor
        vm.prank(victim);
        vault.deposit(1_000_000e6);
        console2.log("Initial deposit: 1M USDC");

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before:", priceBefore);

        // Attacker front-runs the yield report with a deposit
        vm.prank(attacker);
        uint256 attackerSharesBefore = vault.deposit(1_000_000e6);
        console2.log("Attacker front-runs with 1M, gets shares:", attackerSharesBefore);

        // Yield reported
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after yield:", priceAfter);

        // Calculate attacker's value
        uint256 attackerValue = vault.sharesToUsdc(attackerSharesBefore);
        console2.log("Attacker's value now:", attackerValue);
        console2.log("Attacker's profit:", int256(attackerValue) - 1_000_000e6);

        // The attacker got yield, but this is legitimate participation
        // They contributed capital and earned proportional yield
        // This is NOT an exploit - it's just investing before yield
        console2.log("");
        console2.log("RESULT: Not a vulnerability - attacker just invested early");
        console2.log("No flash loan possible due to cooldown on exit");
    }

    /**
     * @notice Test: Owner front-running deposits with yield report
     * @dev FINDING: CENTRALIZATION RISK - Owner CAN manipulate price via yield
     *      This is a trust assumption, not a bug (owner is trusted)
     */
    function test_ANALYSIS_OwnerFrontRunsDeposit() public {
        console2.log("=== OWNER FRONT-RUNNING ANALYSIS ===");
        console2.log("");

        // Initial deposit
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        uint256 priceBefore = vault.sharePrice();
        console2.log("Price before:", priceBefore);

        // Owner reports yield BEFORE new user deposits
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after owner yield report:", priceAfter);

        // New user deposits at inflated price
        address newUser = makeAddr("newUser");
        usdc.mint(newUser, 1_000_000e6);
        vm.startPrank(newUser);
        usdc.approve(address(vault), type(uint256).max);
        uint256 newUserShares = vault.deposit(1_000_000e6);
        vm.stopPrank();

        console2.log("New user deposits 1M, gets shares:", newUserShares);

        // New user gets fewer shares due to higher price
        // But this is CORRECT BEHAVIOR - yield already happened
        console2.log("");
        console2.log("RESULT: Not a bug - this is expected behavior");
        console2.log("Yield increases price, new depositors get fewer shares");
        console2.log("This is a trust assumption on owner/oracle");
    }

    /**
     * @notice Test: Deposit-then-cancel arbitrage window
     * @dev FINDING: LOW RISK - Cancellation only within 1 hour
     */
    function test_ANALYSIS_DepositCancelArbitrage() public {
        console2.log("=== DEPOSIT-CANCEL ARBITRAGE ANALYSIS ===");
        console2.log("");

        // User deposits
        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1_000_000e6);
        console2.log("Attacker deposits 1M");

        // Request withdrawal immediately
        vm.prank(attacker);
        uint256 requestId = vault.requestWithdrawal(attackerShares);
        console2.log("Requests withdrawal");

        // Check if yield is about to be positive
        // If so, cancel withdrawal to keep shares
        vm.warp(block.timestamp + 30 minutes);

        // Attacker can cancel within 1 hour
        vm.prank(attacker);
        vault.cancelWithdrawal(requestId);
        console2.log("Cancelled withdrawal within window");

        // Now if yield is reported, attacker benefits
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(100_000e6);

        uint256 attackerValue = vault.sharesToUsdc(attackerShares);
        console2.log("Attacker value after yield:", attackerValue);

        console2.log("");
        console2.log("RESULT: Low risk - this is just optionality");
        console2.log("User can always hold shares; cancel just provides flexibility");
    }
}
