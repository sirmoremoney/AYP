// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {VaultShare} from "../../src/VaultShare.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title RoundingExploit
 * @notice Tests for precision and rounding vulnerabilities
 * @dev Analyzes:
 *      1. First depositor inflation attack
 *      2. Dust deposit attacks
 *      3. Rounding direction exploitation
 *      4. Extreme value edge cases
 */
contract RoundingExploit is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);

        vault = new USDCSavingsVault(
            address(usdc),
            address(roleManager),
            multisig,
            treasury,
            0.2e18,
            1 days,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        vault.setMaxYieldChangePercent(0);
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 100_000_000e6);
        usdc.mint(victim, 100_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice Test: Classic first depositor / donation attack
     * @dev FINDING: NOT VULNERABLE - NAV is computed from deposits, not balance
     */
    function test_ANALYSIS_FirstDepositorAttack_NotVulnerable() public {
        console2.log("=== FIRST DEPOSITOR ATTACK ANALYSIS ===");
        console2.log("");

        // Classic attack: Deposit 1 wei, donate large amount, inflate share price
        // Victim deposits, gets 0 shares due to inflated price

        // Step 1: Attacker deposits minimum amount
        vm.prank(attacker);
        try vault.deposit(1) {
            console2.log("Attacker deposited 1 wei");
        } catch {
            console2.log("1 wei deposit reverted (ZeroShares) - PROTECTED");
        }

        // Even with 1 USDC deposit:
        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1e6);
        console2.log("Attacker deposited 1 USDC, got shares:", attackerShares);

        // Step 2: Attacker donates directly to vault
        vm.prank(attacker);
        usdc.transfer(address(vault), 1_000_000e6);
        console2.log("Attacker donated 1M USDC directly to vault");

        // Check share price - should NOT be affected
        uint256 priceAfterDonation = vault.sharePrice();
        console2.log("Share price after donation:", priceAfterDonation);

        // Share price should still be ~1e6 (1 USDC per share)
        // because totalAssets() uses totalDeposited, not balance
        assertApproxEqAbs(priceAfterDonation, 1e6, 1, "Price should not be affected by donation");

        // Step 3: Victim deposits
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        console2.log("Victim deposited 1M USDC, got shares:", victimShares);

        // Victim should get ~1M shares (1:1)
        assertApproxEqRel(victimShares, 1_000_000e18, 0.01e18, "Victim should get fair shares");

        console2.log("");
        console2.log("RESULT: NOT VULNERABLE");
        console2.log("Donation does not affect share price");
        console2.log("NAV computed from totalDeposited, not usdc.balanceOf()");
    }

    /**
     * @notice Test: Dust deposit attack
     * @dev FINDING: PROTECTED - ZeroShares revert prevents dust attacks
     */
    function test_ANALYSIS_DustDepositAttack_Protected() public {
        console2.log("=== DUST DEPOSIT ATTACK ANALYSIS ===");
        console2.log("");

        // Inflate price via yield
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(1_000_000e6); // 100% yield

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after yield:", priceAfter);

        // At this price, 1 USDC = 0.5 shares
        // Try depositing very small amount
        vm.prank(attacker);
        try vault.deposit(1) {
            console2.log("Dust deposit succeeded");
        } catch (bytes memory reason) {
            console2.log("Dust deposit reverted - PROTECTED");
            // Should revert with ZeroShares
        }

        console2.log("");
        console2.log("RESULT: PROTECTED by ZeroShares check");
    }

    /**
     * @notice Test: Rounding direction favors protocol
     * @dev FINDING: CORRECT - Rounding always favors protocol
     */
    function test_ANALYSIS_RoundingDirection() public {
        console2.log("=== ROUNDING DIRECTION ANALYSIS ===");
        console2.log("");

        // Setup: Create non-trivial share price
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(333_333e6); // Create odd price

        uint256 price = vault.sharePrice();
        console2.log("Share price:", price);

        // Test usdcToShares rounding
        uint256 usdcAmount = 1_000_000e6;
        uint256 calculatedShares = vault.usdcToShares(usdcAmount);
        uint256 backToUsdc = vault.sharesToUsdc(calculatedShares);

        console2.log("Original USDC:", usdcAmount);
        console2.log("Converted to shares:", calculatedShares);
        console2.log("Back to USDC:", backToUsdc);

        // Rounding should favor protocol (user gets less back)
        assertLe(backToUsdc, usdcAmount, "Rounding should favor protocol");

        console2.log("");
        console2.log("RESULT: Correct rounding - favors protocol");
    }

    /**
     * @notice Test: Extreme values (near overflow)
     * @dev FINDING: SAFE - Solidity 0.8+ has built-in overflow protection
     */
    function test_ANALYSIS_ExtremeValues() public {
        console2.log("=== EXTREME VALUE ANALYSIS ===");
        console2.log("");

        // Deposit very large amount
        uint256 largeAmount = 1_000_000_000_000e6; // 1 trillion USDC
        usdc.mint(attacker, largeAmount);
        vm.prank(attacker);
        usdc.approve(address(vault), largeAmount);

        vm.prank(attacker);
        uint256 largeShares = vault.deposit(largeAmount);
        console2.log("Deposited 1T USDC, got shares:", largeShares);

        // Report large yield
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(int256(largeAmount / 10)); // 10% yield

        uint256 price = vault.sharePrice();
        console2.log("Price after large yield:", price);

        // Calculations should still work
        uint256 value = vault.sharesToUsdc(largeShares);
        console2.log("Value of shares:", value);

        console2.log("");
        console2.log("RESULT: Safe - no overflow with extreme values");
    }

    /**
     * @notice Test: Zero NAV edge case
     * @dev FINDING: HANDLED - NAV returns 0, price returns INITIAL_SHARE_PRICE
     */
    function test_ANALYSIS_ZeroNavEdgeCase() public {
        console2.log("=== ZERO NAV EDGE CASE ===");
        console2.log("");

        // Deposit
        vm.prank(victim);
        vault.deposit(1_000_000e6);

        // Massive loss (more than deposited)
        vm.warp(block.timestamp + 1 days);
        vault.reportYieldAndCollectFees(-2_000_000e6); // Loss exceeds deposits

        uint256 nav = vault.totalAssets();
        uint256 price = vault.sharePrice();

        console2.log("NAV after massive loss:", nav);
        console2.log("Share price:", price);

        // NAV should be 0 (clamped), price should be 0 or INITIAL
        assertEq(nav, 0, "NAV should be clamped to 0");

        console2.log("");
        console2.log("RESULT: Handled - NAV clamped to 0");
    }
}
